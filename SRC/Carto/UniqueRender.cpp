/* Generated by Together */
#include "stdafx.h"
#include "UniqueRender.h"
#include "IArchive.h"
#include "Feature.h"
#include "IFeatureCursor.h"
#include "SymbolFactory.h"
#include "IFeatureClass.h"
#include "IFeatureSelection.h"

Carto::CUniqueRender::CUniqueRender()
{
	m_type = UNIQUERENDER;
}

Carto::CUniqueRender::~CUniqueRender()
{

}

void Carto::CUniqueRender::Draw( Display::IDisplayPtr pDisplay, Geodatabase::ICursorPtr pCursor )
{
	Geodatabase::IFeatureCursorPtr pFeatureCursor = pCursor;
	if( pCursor == NULL )
	{
		return;
	}

	long UniqueFieldIndex = -1;
	std::string fname;
	if( m_AliasName.length() == 0 )
		fname = m_RendFieldsStr;
	else
		fname = m_AliasName;

	Geodatabase::IFeatureClass *pFeatureClass =dynamic_cast<Geodatabase::IFeatureClass*>(pFeatureCursor->GetTable());

	UniqueFieldIndex =pFeatureClass->FindField(fname.c_str());


	if( UniqueFieldIndex == -1 )
	{
		return;
	}

	/*for (Str_Iterator it = m_UniqueStrSyms.begin() ; it != m_UniqueStrSyms.end() ; it++ )
	{
		pDisplay->SetSymbolInStack( it->second.pSymbol.get() );
	}*/
	//按照唯一值的排列顺序将符号插入IDisplay的符号队列中
	for(int i=0;i<m_indexList.size();i++)
	{
        pDisplay->SetSymbolInStack( m_UniqueStrSyms[m_indexList[i]].pSymbol.get());
	}
	MapStr::size_type  lDefaultSymbol;

	if( m_pDefaultSymbol != NULL )
	{
		pDisplay->SetSymbolInStack( m_pDefaultSymbol.get() );
		lDefaultSymbol = m_UniqueStrSyms.size();
	}
	else
	{
		lDefaultSymbol = -1;
	}
	Geodatabase::CFeaturePtr pfeature;
	GEOMETRY::geom::Geometry *pGeo = NULL;
	long lSelSymbol = 0;

	pDisplay->Begin();

	long nshape =0;

	//动态投影
	if(m_pAffineTransform && m_pAffineTransform->GetEnableUsed())
	{
		GEOMETRY::geom::Geometry *pShape;
		// 字符传类型
		while(!pFeatureCursor->IsEOF())
		{
			pfeature = pFeatureCursor->NextRow();

			nshape++;

			Str_Iterator item = m_UniqueStrSyms.find( pfeature->GetValue(UniqueFieldIndex).GetasString());

			if( item._Mynode() != m_UniqueStrSyms.end()._Mynode() )
			{
				lSelSymbol = ( long )( * item ).second.nIndex;
				pDisplay->SelectStackSymbol( lSelSymbol );
			}
			else if( lDefaultSymbol == -1 )
				continue;
			else
				pDisplay->SelectStackSymbol( lDefaultSymbol );

			pShape =pfeature->GetShape();
			if(pShape)
			{
			   m_pAffineTransform->Transform(pShape);
               pDisplay->Draw(pShape);
			}

			if(nshape%MAX_DISPLAY_SHAPE==0)
			{
				pDisplay->UpdateGeography();
			}
			

		}
	}
	else
	{
		// 字符传类型
		while(!pFeatureCursor->IsEOF())
		{
			pfeature = pFeatureCursor->NextRow();

			nshape++;

			Str_Iterator item = m_UniqueStrSyms.find( pfeature->GetValue(UniqueFieldIndex).GetasString());

			if( item._Mynode() != m_UniqueStrSyms.end()._Mynode() )
			{
				lSelSymbol = ( long )( * item ).second.nIndex;
				pDisplay->SelectStackSymbol( lSelSymbol );
			}
			else if( lDefaultSymbol == -1 )
				continue;
			else
				pDisplay->SelectStackSymbol( lDefaultSymbol );
			pDisplay->Draw( pfeature->GetShape() );

			if(nshape%MAX_DISPLAY_SHAPE==0)
			{
				pDisplay->UpdateGeography();
			}

		}
	}
	

	pDisplay->End();
}

void Carto::CUniqueRender::HighLightDraw( Display::IDisplayPtr pDisplay, Geodatabase::ICursorPtr pCursor )
{
	// 设置选择符号的颜色
	int Size = GetCount();
	Display::ISymbolPtr *symbolGroup = new Display::ISymbolPtr[Size+1];
	/*COLORREF *color = NULL;
	color =	new COLORREF[Size+1];*/
	int nIndex = 0;
	for (Str_Iterator it = m_UniqueStrSyms.begin() ; it != m_UniqueStrSyms.end() ; it++ )
	{
		symbolGroup[nIndex] = it->second.pSymbol->Clone();
		it->second.pSymbol->SetColor( m_HighLightColor );
		++nIndex;
	}	
	if( m_pDefaultSymbol != NULL )
	{
		symbolGroup[nIndex] = m_pDefaultSymbol->Clone();
		m_pDefaultSymbol->SetColor( m_HighLightColor );
	}
	Draw( pDisplay , pCursor );

	// 还原颜色
	 nIndex = 0;
	for (Str_Iterator it = m_UniqueStrSyms.begin() ; it != m_UniqueStrSyms.end() ; it++ )
	{
		 it->second.pSymbol = symbolGroup[nIndex];
		++nIndex;
	}	
	if( m_pDefaultSymbol != NULL )
		m_pDefaultSymbol =  symbolGroup[nIndex];
	if( symbolGroup != NULL)
	{
		delete []symbolGroup;
		symbolGroup = NULL;
	}
}

void Carto::CUniqueRender::HighLightDraw(Display::IDisplayPtr pDisplay, Geodatabase::ISelctionSet* pSelections)
{
	if(!pDisplay || !pSelections)
	{
		return;
	}
	//得到矢量数据源
	Geodatabase::IFeatureClass *pFeatureClass =dynamic_cast<Geodatabase::IFeatureClass*>(pSelections->GetTable());
	if(!pFeatureClass)
	{
		return;
	}

	// 设置选择符号的颜色
	Display::ISymbolPtr copySymbol;
	//如果存在高亮符号，则使用高亮符号
	if(m_pHighLightSymbol)
	{
		copySymbol =m_pHighLightSymbol;
	}
	else
	{
		if(!m_pDefaultSymbol)
		{
            return;
		}
		copySymbol =m_pDefaultSymbol->Clone();
		copySymbol->SetColor( m_HighLightColor );
	}


	long index;
	pSelections->ResetIndex();
	GEOMETRY::geom::Geometry *pShape =NULL;
	GEOMETRY::geom::Envelope envelop;
	pDisplay->GetDisplayTransformation().GetGeoBound(envelop);

	pDisplay->SetSymbol( copySymbol.get() );

	pDisplay->Begin();

	Geodatabase::IFeatureSelection* pFeatureSelection =dynamic_cast<Geodatabase::IFeatureSelection*>(pSelections);

	if(pFeatureSelection!=NULL)
	{
		while(!pFeatureSelection->IsEOF())
		{
			pShape =(GEOMETRY::geom::Geometry*)pFeatureSelection->NextShape();
			if(pShape)
			{
				//判断是否在视图范围内
				if(envelop.intersects(pShape->getEnvelopeInternal()))
				{
					pDisplay->Draw( pShape );
				}
			}
		}
	}
	else
	{
		while(!pSelections->IsEOF())
		{
			index =pSelections->NextID();
			pShape =pFeatureClass->GetFeatureShape(index);
			if(pShape)
			{
				//判断是否在视图范围内
				if(envelop.intersects(pShape->getEnvelopeInternal()))
				{
					pDisplay->Draw( pShape );
				}
				delete pShape;
			}
		}
	}
	

	pDisplay->End();
}

std::string Carto::CUniqueRender::GetRendFieldsStr()
{
	
	return m_RendFieldsStr;
	
}

void Carto::CUniqueRender::SetUniqueFieldsStr(std::string RendFields , std::string AliasName)
{
	m_RendFieldsStr = RendFields;
	m_AliasName = AliasName;
}

bool Carto::CUniqueRender::EraseUniqueValueSymbol( std::string Value )
{
	if( Value.length() == 0 )
		return false;
	m_UniqueStrSyms.erase( Value );
	return true;
}


void Carto::CUniqueRender::SetUniqueValue( std::string Value, std::string strLabel,Display::ISymbolPtr pSymbol)
{
	if( m_UniqueStrSyms[Value].pSymbol == NULL )
	{
		m_UniqueStrSyms[Value].nIndex = ( long )m_UniqueStrSyms.size()-1;
		m_indexList.push_back(Value);
	}
	m_UniqueStrSyms[Value].pSymbol = pSymbol;
	m_UniqueStrSyms[Value].strLabel =strLabel;

}

Display::ISymbolPtr Carto::CUniqueRender::GetUniqueValue( std::string Value  )
{
	if( Value .length() == 0)
		return NULL;
  return m_UniqueStrSyms[Value].pSymbol;

}

bool Carto::CUniqueRender::SetDefaultSymbol( Display::ISymbolPtr pSymbol )
{
	m_pDefaultSymbol = pSymbol;
	return true;
}
Display::ISymbolPtr Carto::CUniqueRender::GetDefaultSymbol(void)
{
	return m_pDefaultSymbol;
}
void Carto::CUniqueRender::serialization(SYSTEM::IArchive &ar)
{
	IRender::serialization( ar );
	ar & m_RendFieldsStr;
	ar & m_AliasName;
	ar & m_strHeading;
	ar & m_DefaultLabel;


	std::string strVal;
	Display::ISymbolPtr pSymbol;
	long nIndex;
	int nCount;
	if( ar.IsRead() )
	{	
		std::string strLabel;

		ar & nCount;
		for ( int i = 0; i < nCount; i++ )
		{
			ar & strVal;

			ar & strLabel;

			pSymbol = Display::CSymbolFactory::CreateSymbolFromStream( ar ); 

			m_UniqueStrSyms[ strVal ].pSymbol = pSymbol;
			m_UniqueStrSyms[strVal].strLabel =strLabel;
			m_UniqueStrSyms[strVal].nIndex =i;

			m_indexList.push_back(strVal);
		}

		ar & m_DefaultLabel;

		m_pDefaultSymbol = Display::CSymbolFactory::CreateSymbolFromStream( ar ); 
	}
	else
	{
		//写入m_indexList的长度
        nCount =m_indexList.size();
		
		ar &nCount;
        //按照图例顺序写入符号和值,图例标签
		for(int i=0;i<nCount;i++)
		{
			//唯一值
			ar & m_indexList[i];
            //唯一值标签
			ar & (m_UniqueStrSyms[m_indexList[i]].strLabel);
           //符号
			m_UniqueStrSyms[m_indexList[i]].pSymbol->serialization( ar );
		}

        ar & m_DefaultLabel;
		m_pDefaultSymbol->serialization( ar );
	}
}

void Carto::CUniqueRender::clear(void)
{
	if( m_UniqueStrSyms.size() != 0 )
	{
		m_UniqueStrSyms.clear();
		
	}
	m_indexList.clear();
}
long Carto::CUniqueRender::GetCount()
{
	return (long)m_UniqueStrSyms.size();
}

void  Carto::CUniqueRender::GetSymbolAndValueArray(  std::vector< std::string > & arrayStrValue, 
													 std::vector< Display::ISymbolPtr > & arraySymbol )
{
	for (Str_Iterator it = m_UniqueStrSyms.begin() ; it != m_UniqueStrSyms.end() ; it++ )
	{
		arrayStrValue.push_back(it->first);
		arraySymbol.push_back(it->second.pSymbol);
	}
}

std::string Carto::CUniqueRender::GetValue(long index)
{
	if(index<0 || index>=m_indexList.size())
	{
		return "";
	}
	return m_indexList[index];
}

std::string Carto::CUniqueRender::GetLabel(std::string value)
{
	return m_UniqueStrSyms[value].strLabel;
}

void Carto::CUniqueRender::SetHeading(std::string strHeading)
{
	m_strHeading =strHeading;
}

std::string Carto::CUniqueRender::GetHeading()
{
	return m_strHeading;
}

std::string Carto::CUniqueRender::GetDefaultLabel()
{
	return m_DefaultLabel;
}

void Carto::CUniqueRender::SetDefaultLabel(std::string strLable)
{
	m_DefaultLabel =strLable;
}


Carto::CLegendInfoPtr Carto::CUniqueRender::GetLegendInfo()
{
	CLegendInfoPtr pLegendInfo(new CLegendInfo());

	//只有一个Gruop
	CLegendGroupPtr pGroup(new CLegendGroup());

	pGroup->SetHeading(m_strHeading);
	LegendItem item;

	for(int i=0;i<m_indexList.size();i++)
	{
		item.pSymbol =m_UniqueStrSyms[m_indexList[i]].pSymbol;
		item.strLabel =m_UniqueStrSyms[m_indexList[i]].strLabel;
		pGroup->AddItem(item);
	}

	pLegendInfo->AddGroup(pGroup);

	return pLegendInfo;
}