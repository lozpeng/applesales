/* Generated by Together */
#include "stdafx.h"
#include "ConfigItem.h"
#include "Configer.h"
#include "xmlstring.h"

using namespace CAT3_RAW_NUMERIC_SEP_UNDERSCORE(xercesc,3,0);

SYSTEM::CConfigItem::CConfigItem()
{
	m_curValue = NULL;
	itemElement = NULL;
	doc = NULL;
}

SYSTEM::CConfigItem::~CConfigItem()
{
	if( m_curValue != NULL )
		XMLString::release(&m_curValue);
}

// 当节点名称唯一时，通过名字得到
SYSTEM::IConfigItemPtr SYSTEM::CConfigItem::GetChildByName(const char *Name)
{	
	DOMNodeList*    nodeList = ((DOMElement*)itemElement)->getElementsByTagName(X(Name));
	if( nodeList->getLength() != 1 )
		return NULL;
	
	CConfigItem* item = new CConfigItem;
	item->itemElement = nodeList->item(0);
	item->doc = doc;

	return IConfigItemPtr(item);
}

SYSTEM::IConfigItemPtr SYSTEM::CConfigItem::GetChilds(long i)
{
	i++;
	if(i<1)
	{
		return NULL;
	}
	if(!itemElement)
	{
		return NULL;
	}
	DOMNode *child=0;
	child =((DOMElement*)itemElement)->getFirstChild();
	if(!child)
	{
		return NULL;
	}
	CConfigItem *item=new CConfigItem;
	while (child != 0) {
		////杨小玲test
		//if( m_curValue != NULL )
		//	XMLString::release( &m_curValue );
		//m_curValue = XMLString::transcode(child->getNodeName());
		////
		if(child->getNodeType()==DOMNode::TEXT_NODE)
		{	
			child = child->getNextSibling();
			continue;
		}
		i--;
		if(i==0)
		{
			item->itemElement=child;
			item->doc=this->doc;
			break;
		}
		child = child->getNextSibling();
	}
	if(!child)
	{
		delete item;
		item=0;
		return NULL;
	}
	return IConfigItemPtr(item);
}

SYSTEM::IConfigItemPtr SYSTEM::CConfigItem::GetParent()
{
	DOMNode *pParent = ((DOMElement*)itemElement)->getParentNode();
	if(pParent == NULL)
		return NULL;

	CConfigItem* item = new CConfigItem;
	item->itemElement =pParent;
	item->doc = this->doc;

	return IConfigItemPtr((IConfigItem*)item);
}

const char * SYSTEM::CConfigItem::GetName()
{	
	if( m_curValue != NULL )
		XMLString::release( &m_curValue );
	m_curValue = XMLString::transcode(((DOMElement*)itemElement)->getNodeName());
	return m_curValue;
}
void SYSTEM::CConfigItem::SetName(const char * name)
{
	//设置当前节点的名字
	if(!name)
	{
		return;
	}
	XMLCh *t = XMLString::transcode(name);
	((XERCES_CPP_NAMESPACE_QUALIFIER DOMDocument*)doc)->renameNode((DOMElement*)itemElement,0,t);
	XMLString::release(&t);
}
const char* SYSTEM::CConfigItem::GetValue()
{
	if(!(((DOMElement*)itemElement)->getFirstChild()!=0&&((DOMElement*)itemElement)->getFirstChild()->getNodeType()==DOMNode::TEXT_NODE))	//如果所取节点并非文本节点
	{	
		return NULL;
	}
	if( m_curValue != NULL )
		XMLString::release(&m_curValue);

	m_curValue = XMLString::transcode(((DOMElement*)itemElement)->getFirstChild()->getNodeValue());
	return m_curValue;
}
void SYSTEM::CConfigItem::SetValue(const char *value)
{
	if(!value)
	{
		return;
	}
	if(((DOMElement*)itemElement)->getFirstChild()!=0&&((DOMElement*)itemElement)->getFirstChild()->getNodeType()==DOMNode::TEXT_NODE)		//所取节点如为文本节点
		((DOMElement*)itemElement)->getFirstChild()->setNodeValue(XMLString::transcode(value));	//则改变其值
	else																	//否则插入新创建的文本节点
	{
		XMLCh *t = XMLString::transcode(value);
		DOMText *OneDataValue = ((XERCES_CPP_NAMESPACE_QUALIFIER DOMDocument*)doc)->createTextNode(t);
		XMLString::release(&t);
		((DOMElement*)itemElement)->insertBefore(OneDataValue,((DOMElement*)itemElement)->getFirstChild());
	}
}
long SYSTEM::CConfigItem::GetChildCount()
{
	int iCount=0;
	DOMNode *child = ((DOMElement*)itemElement)->getFirstChild();
	if(!child)
	{
		return 0;
	}
	while (child != 0) {
		if(child->getNodeType()==DOMNode::TEXT_NODE)
		{	
			child = child->getNextSibling();
			continue;
		}
		iCount++;
		child = child->getNextSibling();
	}
	return iCount;
}
const char* SYSTEM::CConfigItem::GetProperties(const char * propName)
{
	if(!propName)
	{
		return NULL;
	}
	if(((DOMElement*)itemElement)->hasAttributes())		//判断当前节点是否存在属性
	{
		DOMNamedNodeMap *pAttributes = ((DOMElement*)itemElement)->getAttributes();
		XMLCh *t = XMLString::transcode(propName);
		DOMAttr *pAttributeNode = (DOMAttr*)pAttributes->getNamedItem(t);
		XMLString::release(&t);
		if( m_curValue != NULL )
			XMLString::release(&m_curValue);
		if(!pAttributeNode)		//属性名称不存在
			m_curValue = NULL;
		else
			m_curValue = XMLString::transcode(pAttributeNode->getValue());
		return m_curValue;
	}
	else
	{
		return NULL;
	}	
}
void SYSTEM::CConfigItem::SetProperties(const char * propName, const char * value)
{
	if(!propName||!value)
	{
		return;
	}
	if(((DOMElement*)itemElement)->hasAttributes())
	{
		DOMNamedNodeMap *pAttributes = ((DOMElement*)itemElement)->getAttributes();
		XMLCh *t = XMLString::transcode(propName);
		DOMAttr *pAttributeNode = (DOMAttr*)pAttributes->getNamedItem(t);
		XMLString::release(&t);
		if(!pAttributeNode)
		{
			return;	//属性名错误，抛出异常
		}
		t = XMLString::transcode(value);
		pAttributeNode->setValue(t);
		XMLString::release(&t);
	}
	else
	{
		return;
	}	 
}
SYSTEM::IConfigItemPtr SYSTEM::CConfigItem::AddChildNode(const char *name)
{
	if(!name)
	{
		return NULL;
	}
	XMLCh *t = XMLString::transcode(name);
	DOMElement*  OneElement =((XERCES_CPP_NAMESPACE_QUALIFIER DOMDocument*)doc)->createElement(t);
	((DOMElement*)itemElement)->appendChild(OneElement);
	XMLString::release(&t);

	CConfigItem *item=new CConfigItem;
	item->doc = doc;
	item->itemElement = OneElement;
	return IConfigItemPtr( item );
}

bool SYSTEM::CConfigItem::DeleteChildNode(long i)
{
	if(i<1)
	{
		return false;
	}
	DOMNode *child = ((DOMElement*)itemElement)->getFirstChild();
	if(!child)
		return false;
	while (child != 0) {
		////杨小玲test
		//if( m_curValue != NULL )
		//	XMLString::release( &m_curValue );
		//m_curValue = XMLString::transcode(child->getNodeName());
		////
		if(child->getNodeType()==DOMNode::TEXT_NODE)
		{	
			child = child->getNextSibling();
			continue;
		}
		i--;
		if(i==0)
		{
			((DOMElement*)itemElement)->removeChild(child);
			return true;
		}
		child = child->getNextSibling();
	}
	return false;
}

bool SYSTEM::CConfigItem::DeleteChildByName(const char* name)
{
	DOMNodeList*    nodeList = ((DOMElement*)itemElement)->getElementsByTagName(X(name));
	if( nodeList->getLength() != 1 )
		return false;

	DOMNode *child = nodeList->item(0);
	if(child == 0)
		return false;

	((DOMElement*)itemElement)->removeChild(child);
		return true;
}

void SYSTEM::CConfigItem::AddAttribute(const char *name,const char *value)
{
	if(!name||!value)
	{
		return;
	}
	XMLCh *t = XMLString::transcode(name);
	XMLCh *t2= XMLString::transcode(value);
	((DOMElement*)itemElement)->setAttribute(t,t2);
	XMLString::release(&t);
	XMLString::release(&t2);
}

void SYSTEM::CConfigItem::DeleteAttributeByName(const char *name)
{
	if(!name)
	{
		return;
	}
	if(((DOMElement*)itemElement)->hasAttributes())
	{
		XMLCh *t = XMLString::transcode(name);
		((DOMElement*)itemElement)->removeAttribute(t);
		XMLString::release(&t);
	}
	else
	{
		return;	//当前节点不存在属性
	}
}

void SYSTEM::CConfigItem::RemoveAllAttributes()
{
	if(((DOMElement*)itemElement)->hasAttributes())
	{
		DOMNamedNodeMap *pAttributes = ((DOMElement*)itemElement)->getAttributes();
		XMLSize_t count = pAttributes->getLength();
		DOMAttr* pNode = NULL;
		for (XMLSize_t i = 0 ; i < count ; ++i)
		{
			pNode = (DOMAttr*)pAttributes->item(0);

			if( m_curValue != NULL )
				XMLString::release(&m_curValue);
			if(!pNode)		//属性名称不存在
				m_curValue = NULL;
			else
				m_curValue = XMLString::transcode(pNode->getName());/*DOMAttr **/

			((DOMElement*)itemElement)->removeAttribute(pNode->getName());
		}
	}
}

SYSTEM::IConfigItemPtr SYSTEM::CConfigItem::GetFirstChild()
{
	DOMNode *FirstChild = ((DOMElement*)itemElement)->getFirstChild();
	if(FirstChild == NULL)
		return NULL;
	
	while(FirstChild != NULL && FirstChild->getNodeType() == DOMNode::TEXT_NODE)
		FirstChild = FirstChild->getNextSibling();

	if(FirstChild == NULL)
		return NULL;

	CConfigItem* item = new CConfigItem;
	item->itemElement = FirstChild;
	item->doc = doc;
	
	return IConfigItemPtr((IConfigItem*)item);
}

SYSTEM::IConfigItemPtr SYSTEM::CConfigItem::GetLastChild()
{
	DOMNode *LastChild = ((DOMElement*)itemElement)->getLastChild();
	if(LastChild == NULL)
		return NULL;
	
	while(LastChild != NULL && LastChild->getNodeType() == DOMNode::TEXT_NODE)
		LastChild = LastChild->getPreviousSibling();

	if(LastChild == NULL)
		return NULL;

	CConfigItem* item = new CConfigItem;
	item->itemElement = LastChild;
	item->doc = doc;
	
	return IConfigItemPtr((IConfigItem*)item);
}


SYSTEM::IConfigItemPtr SYSTEM::CConfigItem::GetPreviousSibling()
{
	DOMNode *sbliding = ((DOMElement*)itemElement)->getPreviousSibling();
	if(sbliding == NULL)
		return NULL;

	while(sbliding != NULL && sbliding->getNodeType() == DOMNode::TEXT_NODE)	
		sbliding = sbliding->getNextSibling();

	if(sbliding == NULL)
		return NULL;
	CConfigItem* item = new CConfigItem;
	item->itemElement =sbliding;
	item->doc = this->doc;

	return IConfigItemPtr((IConfigItem*)item);

}

SYSTEM::IConfigItemPtr SYSTEM::CConfigItem::GetNextSibling()
{
	DOMNode *sbliding = ((DOMElement*)itemElement)->getNextSibling();
	if(sbliding == NULL)
		return NULL;

	while(sbliding != NULL && sbliding->getNodeType() == DOMNode::TEXT_NODE)	
		sbliding = sbliding->getNextSibling();	

	if(sbliding == NULL)
		return NULL;

	CConfigItem* item = new CConfigItem;
	item->itemElement =sbliding;
	item->doc = this->doc;

	return IConfigItemPtr((IConfigItem*)item);
	
}